<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 界限</title><link>https://blog.limx.dev/post/</link><description>Recent content in Posts on 界限</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 08 May 2021 18:35:53 +0800</lastBuildDate><atom:link href="https://blog.limx.dev/post/feed.xml" rel="self" type="application/rss+xml"/><item><title>Caddy2 + Hugo + Github Actions 的自动化部署博客方案</title><link>https://blog.limx.dev/post/caddy-hugo-github-actions-for-blog/</link><pubDate>Sat, 08 May 2021 18:35:53 +0800</pubDate><guid>https://blog.limx.dev/post/caddy-hugo-github-actions-for-blog/</guid><description>我的博客部署流程如下：
写文章并推送到 username.github.io 仓库的 hugo 分支。 GitHub Actions 自动构建并推送到 main 分支。 GitHub 发送 webhook 请求到自有服务器，服务器拉取更新。 不使用 GitHub Page 的原因主要是在国内访问太慢，而且有服务器闲置，正好用来部署博客。
而使用 GitHub Actions 先构建推送到 main，然后再在服务器上拉取的原因是可以在 GitHub Page 上有一个备份，服务器出现故障时可以先 302 重定向到 GitHub Page，解决故障后切换回来。
为了实现这个流程，在服务器上需要用到一个服务：Caddy
Caddy 是基于 go 编写的 web 服务器，相比于 nginx 和 apache 的优点就是能自动申请 SSL 证书，自动更新证书。
当然，有人会说这类文章网上已经有很多了，为什么还要重复再写一篇。一个重要的原因是网上的的文章都是基于 Caddy V1 版本，而在 Caddy 更新到 V2 版本后，之前的插件都已经失效了。
本着用新不用旧的原则，我也将 Caddy 更新到 V2，但也因为这样需要重新配置第 3 步的部署流程。
为了实现第 3 步，我给 Caddy 写了一个模块：caddy-webhook，下面通过具体的步骤来展示如何使用这个模块。
建立仓库 建立一个 username.github.io 的仓库会自动配置 GitHub Page，并且可以通过直接访问 username.</description></item><item><title>使用 GiHub Actions 构建多架构 Docker 镜像</title><link>https://blog.limx.dev/post/build-docker-image-in-multi-archs-with-github-actions/</link><pubDate>Sat, 17 Apr 2021 15:00:52 +0800</pubDate><guid>https://blog.limx.dev/post/build-docker-image-in-multi-archs-with-github-actions/</guid><description>Docker为我们提供了一个一键式部署代码环境的方式，透过Docker Image我们可以不关心当前的操作系统的环境，只需要拉取镜像下来即可获得一致的运行环境。
但仍存在一个问题，如果你直接使用 docker build ，构建出来的镜像是基于你当前机器的CPU架构。当然，你也可以将代码和 Dockerfile 拉到虚拟机中进行构建，但这会花费很多时间。
通过 GitHub Actions，我们可以在 push 代码的时候，自动进行多架构的镜像构建，不再需要手动构建并推送到 Docker Hub 等镜像仓库中。
下面是一个示例：
这是我在 kea-dhcp4 中使用的 GitHub Actions 构建脚本的一部分
要推送到 DockerHub，则需要在 repo 的 sercrets 中设置 DockerHub 的用户名及 TOKEN
TOKEN 的生成参考：Managing access tokens
要推送到 GitHub 的镜像仓库，即 ghcr.io 中则需要设置 PAT(Personal Access Token)
CR_PAT 的生成参考：Migrating to GitHub Container Registry for Docker images
name:buildon:push:branches:[main ]paths-ignore:- &amp;#34;README.md&amp;#34;jobs:build:runs-on:ubuntu-lateststeps:-name:Checkoutuses:actions/checkout@v2-name:Set up QEMUuses:docker/setup-qemu-action@v1-name:Set up Docker Buildxuses:docker/setup-buildx-action@v1-name:Login to DockerHubuses:docker/login-action@v1with:username:${{ secrets.DOCKERHUB_USERNAME }}password:${{ secrets.DOCKERHUB_TOKEN }}-name:Login to GitHub Container Registryuses:docker/login-action@v1 # 在 sercrets 中设置 CR_PAT# with:registry:ghcr.</description></item><item><title>戴尔 5070MFF 黑苹果体验</title><link>https://blog.limx.dev/post/dell-optiplex-5070mff-hackintosh/</link><pubDate>Wed, 10 Mar 2021 19:09:40 +0800</pubDate><guid>https://blog.limx.dev/post/dell-optiplex-5070mff-hackintosh/</guid><description>EFI开源托管在GitHub：Dell-Optiplex-5070mff-Hackintosh
Tested in Big Sur 11.2.3
配置介绍 硬件配置：
准系统: Dell OptiPlex 5070 Micro Form Factor CPU: Intel® Core™ i5-9500T Processor 核显: Intel® UHD Graphics 630 内存: 8GB DDR4 2666 * 2 双通道 硬盘: KIOXIA RC10 NVME SSD 500G Wi-Fi &amp;amp; Bluetooth: DW1820A 声卡: Realtek ALC255(3234) 板载网卡: Intel I219-LM7 接口配置：
前面板：
通用音频接口 有线音频输出 Type C(USB3.1 Gen2 PowerShare) 注：不是雷电接口 Type-A USB接口(USB 3.1 Gen1 PowerShare) 后面板：
RJ-45网线接口 Type-A USB接口(USB 3.</description></item><item><title>C语言项目单元测试实践</title><link>https://blog.limx.dev/post/c-unittest-example/</link><pubDate>Tue, 22 Dec 2020 21:50:57 +0800</pubDate><guid>https://blog.limx.dev/post/c-unittest-example/</guid><description>前言 最近一段时间在写C语言的课程设计，之前在用 Golang 的时候，Golang 自带单元测试，用起来非常舒服，而C语言不使用框架写测试则会很麻烦，下面通过一个简单的项目来实践在C语言中进行单元测试。
项目中使用 CMocka 作为单元测试框架，使用 CodeCov 检查代码覆盖率。
完整项目代码可以在 GitHub 上查看：c-unittest-example
项目目录 . ├── CMakeLists.txt ├── Makefile ├── README.md ├── cmake │ ├── CMocka.cmake │ └── CodeCov.cmake ├── include │ └── add.h ├── src │ └── add.c └── test ├── CMakeLists.txt ├── add_tests.c └── test.h 4 directories, 10 files 目录说明 cmake: 存放 CMake 的模块文件，包括 CMocka 和 CodeCov。
include: 项目头文件 src: 项目源代码 test: 单元测试代码
项目设置文件 Makefile 用于便携执行单元测试和构建程序
.PHONY: cmake test BUILD_TYPE ?</description></item><item><title>Linux Kernel 实践(二)：劫持系统调用</title><link>https://blog.limx.dev/post/linux-kernel-practice-hijack-syscall/</link><pubDate>Fri, 06 Mar 2020 23:17:11 +0800</pubDate><guid>https://blog.limx.dev/post/linux-kernel-practice-hijack-syscall/</guid><description>使用系统为 Ubuntu，内核版本为 4.4.0-93-generic
劫持系统调用有风险，请不要在实体机上尝试。
前言 添加系统调用有两种方法
修改内核源代码，并重新编译内核 这种耗时耗力，比较麻烦，但是是在原有的系统调用中插入新的系统调用，不会出现冲突等问题。
通过内核模块重新映射系统调用地址 通过拦截系统调用表，将某个系统调用的地址修改成我们自定义的系统系统调用。
什么是系统调用表 在 Linux 中每个系统调用都有相应的系统调用号作为唯一的标识，内核维护一张系统调用表：sys_call_table。
在 64 位系统中，sys_call_table 的定义在 entry/syscall_64.c#L25
asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = { [0 ... __NR_syscall_max] = &amp;amp;sys_ni_syscall, #include &amp;lt;asm/syscalls_64.h&amp;gt;}; 其中 #include &amp;lt;asm/syscalls_64.h&amp;gt; 是通过 entry/syscalls/Makefile 以 entry/syscalls/syscall_64.tbl 为源文件编译生成的。
out := $(obj)/../../include/generated/asm syscall64 := $(srctree)/$(src)/syscall_64.tbl systbl := $(srctree)/$(src)/syscalltbl.sh $(out)/syscalls_64.h: $(syscall64) $(systbl) $(call if_changed,systbl) Makefile 通过 entry/syscalls/syscalltbl.sh 将 syscall_64.tbl 格式化成 __SYSCALL_${abi}($nr, $entry, $compat)
#!/bin/sh in=&amp;#34;$1&amp;#34; out=&amp;#34;$2&amp;#34; grep &amp;#39;^[0-9]&amp;#39; &amp;#34;$in&amp;#34; | sort -n | ( while read nr abi name entry compat; do abi=`echo &amp;#34;$abi&amp;#34; | tr &amp;#39;[a-z]&amp;#39; &amp;#39;[A-Z]&amp;#39;` if [ -n &amp;#34;$compat&amp;#34; ]; then echo &amp;#34;__SYSCALL_${abi}($nr, $entry, $compat)&amp;#34; elif [ -n &amp;#34;$entry&amp;#34; ]; then echo &amp;#34;__SYSCALL_${abi}($nr, $entry, $entry)&amp;#34; fi done ) &amp;gt; &amp;#34;$out&amp;#34; 生成后的 syscall_64.</description></item><item><title>Linux Kernel 实践(一)：Hello LKM</title><link>https://blog.limx.dev/post/linux-kernel-practice-hello/</link><pubDate>Fri, 06 Mar 2020 18:18:09 +0800</pubDate><guid>https://blog.limx.dev/post/linux-kernel-practice-hello/</guid><description>使用系统为 Ubuntu，内核版本为 4.4.0-93-generic
什么是内核模块 Loadable Kernel Modules（LKM）即可加载内核模块，LKM可以动态地加载到内存中，无须重新编译内核。所以它经常被用于一些设备的驱动程序，例如声卡，网卡等等。
内核模块和一般的 C 语言程序不同，它不使用 main() 函数作为入口，并且有如下区别：
非顺序执行：内核模块使用初始化函数来进行注册，并处理请求，初始化函数运行后就结束了。 它可以处理的请求类型在模块代码中定义。 没有自动清理：内核模块申请的所有内存，必须要在模块卸载时手动释放，否则这些内存会无法使用，直到重启，也就是说我们需要在模块的卸载函数（也就是下文写到的退出函数）中，将使用的内存逐一释放。 会被中断：内核模块可能会同时被多个程序/进程使用，构建内核模块时要确保发生中断时行为一致和正确。想了解更多请看：Linux 内核的中断机制 更高级的执行特权：通常分配给内核模块的CPU周期比分配给用户空间程序的要多。编写内核模块时要小心，以免模块对系统的整体性能产生负面影响。 不支持浮点：在Linux内核里无法直接进行浮点计算，因为这样做可以省去在用户态与内核态之间进行切换时保存/恢复浮点寄存器 FPU的操作。 构建前的准备 通过包管理安装 Linux 内核头文件
sudo apt update apt-cache search linux-headers-$(uname -r) apt install linux-headers-$(uname -r) 开始写代码 引入头文件 #include &amp;lt;linux/init.h&amp;gt; // 用于标记函数的宏#include &amp;lt;linux/module.h&amp;gt; //加载内核模块到内核使用的核心头文件#include &amp;lt;linux/kernel.h&amp;gt; // 包含内核使用的类型、宏和函数定义模块信息 MODULE_LICENSE(&amp;#34;GPL&amp;#34;); // 许可类型，它会影响到运行时行为 MODULE_AUTHOR(&amp;#34;WingLim&amp;#34;); // 作者，当使用 modinfo 命令时可见 MODULE_DESCRIPTION(&amp;#34;A simple Linux driver to say hello.&amp;#34;); // 模块描述，参见 modinfo 命令 MODULE_VERSION(&amp;#34;0.1&amp;#34;); // 模块版本 如果没有定义 MODULE_LICENSE ，在编译和加载模块时会报 WARNING: modpost: missing MODULE_LICENSE()</description></item></channel></rss>