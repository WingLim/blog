[{"content":"通过劫持系统调用表，将原有系统调用替换成自定义系统调用。\n使用系统为 Ubuntu，内核版本为 4.4.0-93-generic 劫持系统调用有风险，请不要在实体机上尝试。 前言 添加系统调用有两种方法\n 修改内核源代码，并重新编译内核  这种耗时耗力，比较麻烦，但是是在原有的系统调用中插入新的系统调用，不会出现冲突等问题。\n 通过内核模块重新映射系统调用地址  通过拦截系统调用表，将某个系统调用的地址修改成我们自定义的系统系统调用。\n什么是系统调用表 在 Linux 中每个系统调用都有相应的系统调用号作为唯一的标识，内核维护一张系统调用表，sys_call_table。\n在 64 位系统中，sys_call_table 定义在 arch/x86/entry/syscall_64.c#L25\n1 2 3 4  asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = { [0 ... __NR_syscall_max] = \u0026amp;sys_ni_syscall, #include \u0026lt;asm/syscalls_64.h\u0026gt;};   其中 #include \u0026lt;asm/syscalls_64.h\u0026gt; 为通过 arch/x86/entry/syscalls/syscall_64.tbl 编译生成的，内容截取如下：\n1 2  __SYSCALL_COMMON(0, sys_read, sys_read) __SYSCALL_COMMON(1, sys_write, sys_write)   所以 sys_call_table 展开如下：\n1 2 3 4 5 6  asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = { [0] = sys_read, [1] = sys_write, ... };   即 sys_call_table 是一个数组，索引为系统调用号，值为系统调用函数的起始地址。\n获取 sys_call_table 地址  通过 /boot/System.map 获取 通过 /proc/kallsyms 获取 通过暴力搜索获取  前面两种方式基本一致，都是通过读取文件并过滤的方式获取。\n/boot/System.map 包含整个内核镜像的符号表。\n/proc/kallsyms 不仅包含内核镜像符号表，还包含所有动态加载模块的符号表。\n1 2 3 4 5 6 7 8  # /boot/System.map root@AliECS:~# cat /boot/System.map-$(uname -r) | grep sys_call_table ffffffff81a001c0 R sys_call_table ffffffff81a01520 R ia32_sys_call_table # /proc/kallsyms root@AliECS:~# cat /proc/kallsyms | grep sys_call_table ffffffff81a001c0 R sys_call_table ffffffff81a01520 R ia32_sys_call_table   如果要在 LKM 中 使用的话，可以将地址写在宏定义上，再进行调用。\n1  #define SYS_CALL_TABLE ffffffff81a001c0   但在不同的系统上都得进行修改并重新编译，非常麻烦。\n暴力搜索 前面提到 sys_call_table 是一个数组，索引为系统调用号，值为系统调用函数的起始地址。\n内核内存空间的起始地址 PAGE_OFFSET 变量和 sys_close 系统调用在内核模块中是可见的。系统调用号在同一ABI（x86与x64属于不同ABI）中是高度后向兼容的，可以直接引用（如 __NR_close ）。我们可以从内核空间起始地址开始，把每一个指针大小的内存假设成 sys_call_table 的地址，并用 __NR_close 索引去访问它的成员，如果这个值与 sys_close 的地址相同的话，就可以认为找到了 sys_call_table 的地址。\n更多有关 PAGE_OFFSET 的内容请看：[ARM64 Linux 内核虚拟地址空间](https://geneblue.github.io/2017/04/02/ARM64 Linux 内核虚拟地址空间/)\n下面来看搜索 sys_call_table 的函数：\nULONG_MAX 为 0xFFFFFFFFUL，即 unsigned long 的最大值\n1 2 3 4 5 6 7 8 9 10 11 12  unsigned long **get_sys_call_table(void) { unsigned long **entry = (unsigned long **)PAGE_OFFSET; for (;(unsigned long)entry \u0026lt; ULONG_MAX; entry += 1) { if (entry[__NR_close] == (unsigned long *)sys_close) { return entry; } } return NULL; }   劫持系统调用 写保护 当我们获取到了 sys_call_table 的地址时，并不能直接进行操作，会报错且无法写入，因为在内存中有写保护，这个特性可以通过 CR0 寄存器控制。\nCR0 的第16位比特是写保护，设置时，即使权限级别为0（Linux 有4个权限级别，从0到3，0为最高级。等级0也被称为内核模式），也不能写入只读页。\n我们可以通过 read_cr0 和 write_cr0 这两个函数，来读取和写入 CR0，同时通过 Linux 内核提供的接口 set_bit 和 clear_bit 来操作比特。\n关闭写保护，将第16个比特置为0。\n1 2 3 4 5 6  void disable_write_protection(void) { unsigned long cr0 = read_cr0(); clear_bit(16, \u0026amp;cr0); write_cr0(cr0); }   开启写保护，将第16个比特置为1。\n1 2 3 4 5 6  void enable_write_protection(void) { unsigned long cr0 = read_cr0(); set_bit(16, \u0026amp;cr0); write_cr0(cr0); }   模块代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  /** * @file nice.c * @author WingLim * @date 2020-03-05 * @version 0.1 * @brief 读取及修改一个进程的 nice 值，并返回最新的 nice 值及优先级 prio 的模块化实现 */ #include \u0026lt;linux/init.h\u0026gt;#include \u0026lt;linux/kernel.h\u0026gt;#include \u0026lt;linux/module.h\u0026gt;// 下面这些头文件为自定义系统调用要用到的 #include \u0026lt;linux/pid.h\u0026gt;#include \u0026lt;linux/sched.h\u0026gt;#include \u0026lt;linux/syscalls.h\u0026gt;#include \u0026lt;linux/uaccess.h\u0026gt;#include \u0026lt;linux/unistd.h\u0026gt; // 这里是随便挑了一个系统调用来劫持，224 为 timer_gettime #define the_syscall_num 224  MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;WingLim\u0026#34;); MODULE_DESCRIPTION(\u0026#34;A module to read or set nice value\u0026#34;); MODULE_VERSION(\u0026#34;0.1\u0026#34;); // 用于保存 sys_call_table 地址 unsigned long **sys_call_table; // 用于保存被劫持的系统调用 static int (*anything_saved)(void); // 从内核起始地址开始搜索内存空间来获得 sys_call_table 的内存地址 unsigned long **get_sys_call_table(void) { unsigned long **entry = (unsigned long **)PAGE_OFFSET; for (;(unsigned long)entry \u0026lt; ULONG_MAX; entry += 1) { if (entry[__NR_close] == (unsigned long *)sys_close) { return entry; } } return NULL; } void disable_write_protection(void) { unsigned long cr0 = read_cr0(); clear_bit(16, \u0026amp;cr0); write_cr0(cr0); } void enable_write_protection(void) { unsigned long cr0 = read_cr0(); set_bit(16, \u0026amp;cr0); write_cr0(cr0); } // 这个是用来获取进程的 prio，代码来自 task_prio // 因为这个函数没有导出，所以拷贝一份到源码里 int get_prio(const struct task_struct *p) { return p-\u0026gt;prio - MAX_RT_PRIO; } asmlinkage long sys_setnice(pid_t pid, int flag, int nicevalue, int __user * prio, int __user * nice) { struct pid * kpid; struct task_struct * task; int nicebef; int priobef; kpid = find_get_pid(pid); // 获取 pid  task = pid_task(kpid, PIDTYPE_PID); // 返回 task_struct  nicebef = task_nice(task); // 获取进程当前 nice 值  priobef = get_prio(task); // 获取进程当前 prio 值  if(flag == 1){ set_user_nice(task, nicevalue); printk(\u0026#34;nice value edit before：%d\\tedit after：%d\\n\u0026#34;, nicebef, nicevalue); return 0; } else if(flag == 0){ copy_to_user(nice, (const void*)\u0026amp;nicebef, sizeof(nicebef)); copy_to_user(prio, (const void*)\u0026amp;priobef, sizeof(priobef)); printk(\u0026#34;nice of the process：%d\\n\u0026#34;, nicebef); printk(\u0026#34;prio of the process：%d\\n\u0026#34;, priobef); return 0; } printk(\u0026#34;the flag is undefined!\\n\u0026#34;); return EFAULT; } static int __init init_addsyscall(void) { // 关闭写保护  disable_write_protection(); // 获取系统调用表的地址  sys_call_table = get_sys_call_table(); // 保存原始系统调用的地址  anything_saved = (int(*)(void)) (sys_call_table[the_syscall_num]); // 将原始的系统调用劫持为自定义系统调用  sys_call_table[the_syscall_num] = (unsigned long*)sys_setnice; // 恢复写保护  enable_write_protection(); printk(\u0026#34;hijack syscall success\\n\u0026#34;); return 0; } static void __exit exit_addsyscall(void) { // 关闭写保护  disable_write_protection(); // 恢复原来的系统调用  sys_call_table[the_syscall_num] = (unsigned long*)anything_saved; // 恢复写保护  enable_write_protection(); printk(\u0026#34;resume syscall\\n\u0026#34;); } module_init(init_addsyscall); module_exit(exit_addsyscall);   添加 Makefile 1 2 3 4 5 6 7  obj-m+=hello.o KDIR = /lib/modules/$(shell uname -r)/build all: make -C $(KDIR) M=$(PWD) modules clean: make -C $(KDIR) M=$(PWD) clean   编译模块并启用 1 2 3 4 5 6 7 8 9 10 11 12  # 编译 root@AliECS:~/dev/kernel/nice# make make -C /lib/modules/4.4.0-93-generic/build/ M=/root/dev/kernel/nice modules make[1]: Entering directory `/usr/src/linux-headers-4.4.0-93-generic\u0026#39; CC [M] /root/dev/kernel/nice/nice.o Building modules, stage 2. MODPOST 1 modules CC /root/dev/kernel/nice/nice.mod.o LD [M] /root/dev/kernel/nice/nice.ko make[1]: Leaving directory `/usr/src/linux-headers-4.4.0-93-generic\u0026#39; # 插入模块 root@AliECS:~/dev/kernel/nice# insmod nice.ko   模块测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /*test.c*/ #define _GNU_SOURCE #include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/syscall.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#define __NR_mysetnice 224 //系统调用号  int main() { pid_t tid; int nicevalue; int prio = 0; int nice = 0; tid = getpid(); syscall(__NR_mysetnice,tid,0,-5,\u0026amp;prio,\u0026amp;nice);//read  printf(\u0026#34;pid: %d\\nprio: %d\\nnice: %d\\n\u0026#34;, tid, prio,nice); syscall(__NR_mysetnice,tid,1,-5,\u0026amp;prio,\u0026amp;nice);//set  printf(\u0026#34;pid: %d\\nprio: %d\\nnice: %d\\n\u0026#34;, tid, prio,nice); syscall(__NR_mysetnice,tid,0,-5,\u0026amp;prio,\u0026amp;nice);//read  printf(\u0026#34;pid: %d\\nprio: %d\\nnice: %d\\n\u0026#34;, tid, prio,nice); printf(\u0026#34;*******************************\\n\u0026#34;); syscall(__NR_mysetnice,tid,0,-15,\u0026amp;prio,\u0026amp;nice);//read  printf(\u0026#34;pid: %d\\nprio: %d\\nnice: %d\\n\u0026#34;, tid, prio,nice); syscall(__NR_mysetnice,tid,1,-15,\u0026amp;prio,\u0026amp;nice);//set  printf(\u0026#34;pid: %d\\nprio: %d\\nnice: %d\\n\u0026#34;, tid, prio,nice); syscall(__NR_mysetnice,tid,0,-15,\u0026amp;prio,\u0026amp;nice);//read  printf(\u0026#34;pid: %d\\nprio: %d\\nnice: %d\\n\u0026#34;, tid, prio,nice); return 0; }   编译测试代码并测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  # 编译 test.c root@AliECS:~/dev/kernel/nice# gcc test.c -o test # 执行 root@AliECS:~/dev/kernel/nice# ./test pid: 12872 prio: 20 nice: 0 pid: 12872 prio: 20 nice: 0 pid: 12872 prio: 15 nice: -5 ******************************* pid: 12872 prio: 15 nice: -5 pid: 12872 prio: 15 nice: -5 pid: 12872 prio: 5 nice: -15 # 查看模块输出信息 root@AliECS:~/dev/kernel/nice# tail /var/log/kern.log Mar 7 03:52:47 AliECS kernel: [118009.435431] nice of the process：0 Mar 7 03:52:47 AliECS kernel: [118009.435434] prio of the process：20 Mar 7 03:52:47 AliECS kernel: [118009.435466] nice value edit before：0\tedit after：-5 Mar 7 03:52:47 AliECS kernel: [118009.435475] nice of the process：-5 Mar 7 03:52:47 AliECS kernel: [118009.435476] prio of the process：15 Mar 7 03:52:47 AliECS kernel: [118009.435481] nice of the process：-5 Mar 7 03:52:47 AliECS kernel: [118009.435481] prio of the process：15 Mar 7 03:52:47 AliECS kernel: [118009.435485] nice value edit before：-5\tedit after：-15 Mar 7 03:52:47 AliECS kernel: [118009.435494] nice of the process：-15 Mar 7 03:52:47 AliECS kernel: [118009.435495] prio of the process：5   参考  Linux系统调用流程 Linux Rootkit 系列二：基于修改 sys_call_table 的系统调用挂钩 Kernel Mode Hooking Tutorial OS 实验一 | linux 内核编译及添加系统调用 ","description":"","id":0,"section":"posts","tags":["Linux","Kernel","Module"],"title":"Linux Kernel 实践(二)：劫持系统调用","uri":"https://limxw.com/posts/linux-kernel-%E5%AE%9E%E8%B7%B5%E4%BA%8C%E5%8A%AB%E6%8C%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"content":"实现一个简单的 Linux Kernel Module 并通过自定义参数输出信息。\n使用系统为 Ubuntu，内核版本为 4.4.0-93-generic 什么是内核模块 Loadable Kernel Modules（LKM）即可加载内核模块，LKM可以动态地加载到内存中，无须重新编译内核。所以它经常被用于一些设备的驱动程序，例如声卡，网卡等等。\n内核模块和一般的 C 语言程序不同，它不使用 main() 函数作为入口，并且有如下区别：\n 非顺序执行：内核模块使用初始化函数来进行注册，并处理请求，初始化函数运行后就结束了。 它可以处理的请求类型在模块代码中定义。 没有自动清理：内核模块申请的所有内存，必须要在模块卸载时手动释放，否则这些内存会无法使用，直到重启，也就是说我们需要在模块的卸载函数（也就是下文写到的退出函数）中，将使用的内存逐一释放。 会被中断：内核模块可能会同时被多个程序/进程使用，构建内核模块时要确保发生中断时行为一致和正确。想了解更多请看：Linux 内核的中断机制 更高级的执行特权：通常分配给内核模块的CPU周期比分配给用户空间程序的要多。编写内核模块时要小心，以免模块对系统的整体性能产生负面影响。 不支持浮点：在Linux内核里无法直接进行浮点计算，因为这样做可以省去在用户态与内核态之间进行切换时保存/恢复浮点寄存器 FPU的操作。  构建前的准备 通过包管理安装 Linux 内核头文件\n1 2 3  $ sudo apt update $ apt-cache search linux-headers-$(uname -r) $ apt install linux-headers-$(uname -r)   开始写代码 引入头文件 1 2 3  #include \u0026lt;linux/init.h\u0026gt; // 用于标记函数的宏#include \u0026lt;linux/module.h\u0026gt; //加载内核模块到内核使用的核心头文件#include \u0026lt;linux/kernel.h\u0026gt; // 包含内核使用的类型、宏和函数  定义模块信息 1 2 3 4  MODULE_LICENSE(\u0026#34;GPL\u0026#34;); // 许可类型，它会影响到运行时行为 MODULE_AUTHOR(\u0026#34;WingLim\u0026#34;); // 作者，当使用 modinfo 命令时可见 MODULE_DESCRIPTION(\u0026#34;A simple Linux driver to say hello.\u0026#34;); // 模块描述，参见 modinfo 命令 MODULE_VERSION(\u0026#34;0.1\u0026#34;); // 模块版本   如果没有定义 MODULE_LICENSE ，在编译和加载模块时会报 WARNING: modpost: missing MODULE_LICENSE()\nMODULE_LICENSE 可以选用 “GPL”，“GPL v2”，“GPL and additional rights”，“Dual BSD/GPL”，“Dual MPL/GPL”，“Proprietary” 这几个许可证。更多说明请看：linux/module.h#L209\n初始化函数 static 限制这个函数的可见范围为当前 C 文件\n__init 表示该函数仅在初始化阶段使用，之后释放使用的内存资源：init.h#L7\n@return 执行成功返回 0\n在内核中我们使用 printk() 来打印信息.。printk() 和 printf() 语法一样，但需要先定义消息类型。可用的消息类型可以到 linux/kern_levels.h#L7-#L23 查看\n1 2 3 4  static int __init helloModule_init(void){ printk(KERN_INFO \u0026#34;Hello LKM!\\n\u0026#34;); return 0; }   退出函数 __exit 表示如果这个代码用于一个内置的驱动程序(而不是LKM)，则不需要这个函数。\n1 2 3  static void __exit helloModule_exit(void){ printk(KERN_INFO \u0026#34;Goodbye LKM!\\n\u0026#34;); }   初始化\u0026amp;退出模块 定义在 linux/module.h#L75-#L98\n1 2  module_init(helloModule_init); module_exit(helloModule_exit);   汇总 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /*hello.c*/ #include \u0026lt;linux/init.h\u0026gt;#include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/kernel.h\u0026gt; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;WingLim\u0026#34;); MODULE_DESCRIPTION(\u0026#34;A simple Linux driver to say hello.\u0026#34;); MODULE_VERSION(\u0026#34;0.1\u0026#34;); static int __init helloModule_init(void){ printk(KERN_INFO \u0026#34;Hello LKM!\\n\u0026#34;); return 0; } static void __exit helloModule_exit(void){ printk(KERN_INFO \u0026#34;Goodbye LKM!\\n\u0026#34;); } module_init(helloModule_init); module_exit(helloModule_exit);   编译 添加 Makefile\n1 2 3 4 5 6 7  obj-m+=hello.o KDIR = /lib/modules/$(shell uname -r)/build all: make -C $(KDIR) M=$(PWD) modules clean: make -C $(KDIR) M=$(PWD) clean   注意：Makefile 的基本语法如下，如果缩进不是 \u0026lt;TAB\u0026gt; 的话，会报错。\n\u0026lt;target\u0026gt;: [ \u0026lt;dependency \u0026gt; ]* [ \u0026lt;TAB\u0026gt; \u0026lt;command\u0026gt; \u0026lt;endl\u0026gt; ]+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # 查看当前文件 root@AliECS:~/dev/kernel/hello# ls -l total 8 -rw-r--r-- 1 root root 466 Mar 6 22:53 hello.c -rw-r--r-- 1 root root 154 Mar 6 22:54 Makefile # 编译 root@AliECS:~/dev/kernel/hello# make make -C /lib/modules/4.4.0-93-generic/build/ M=/root/dev/kernel/hello modules make[1]: Entering directory `/usr/src/linux-headers-4.4.0-93-generic\u0026#39; CC [M] /root/dev/kernel/hello/hello.o Building modules, stage 2. MODPOST 1 modules CC /root/dev/kernel/hello/hello.mod.o LD [M] /root/dev/kernel/hello/hello.ko make[1]: Leaving directory `/usr/src/linux-headers-4.4.0-93-generic\u0026#39; # 编译后生成的模块文件 root@AliECS:~/dev/kernel/hello# ls hello.c hello.ko hello.mod.c hello.mod.o hello.o Makefile modules.order Module.symvers   测试模块 查看模块信息 1 2 3 4 5 6 7 8 9  root@AliECS:~/dev/kernel/hello# modinfo hello.ko filename: /root/dev/kernel/hello/hello.ko version: 0.1 description: A simple Linux driver to say hello. author: WingLim license: GPL srcversion: 093C7851C912088AEE5F77C depends: vermagic: 4.4.0-93-generic SMP mod_unload modversions   加载模块 1 2 3 4  root@AliECS:~/dev/kernel/hello# insmod hello.ko root@AliECS:~/dev/kernel/hello# lsmod Module Size Used by hello 16384 0   卸载模块 1  root@AliECS:~/dev/kernel/hello# rmmod hello   查看 printk() 输出信息  使用 dmesg 命令  1 2 3  root@AliECS:~/dev/kernel/hello# dmesg [100339.744628] Hello LKM! [100432.211044] Goodbye LKM!   查看内核日志  1 2 3  root@AliECS:~/dev/kernel/hello# tail /var/log/kern.log Mar 6 22:58:16 AliECS kernel: [100339.744628] Hello LKM! Mar 6 22:59:49 AliECS kernel: [100432.211044] Goodbye LKM!   自定义参数 将 hello.c 修改如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /*hello.c*/ #include \u0026lt;linux/init.h\u0026gt;#include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/kernel.h\u0026gt; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;WingLim\u0026#34;); MODULE_DESCRIPTION(\u0026#34;A simple Linux driver to say hello.\u0026#34;); MODULE_VERSION(\u0026#34;0.1\u0026#34;); static char *name = \u0026#34;LKM\u0026#34;; module_param(name, charp, S_IRUGO); MODULE_PARM_DESC(name, \u0026#34;The name to display in /var/log/kern.log\u0026#34;); static int __init helloModule_init(void){ printk(KERN_INFO \u0026#34;Hello %s!\\n\u0026#34;, name); return 0; } static void __exit helloModule_exit(void){ printk(KERN_INFO \u0026#34;Goodbye %s!\\n\u0026#34;, name); } module_init(helloModule_init); module_exit(helloModule_exit);   解析 static char *name = \u0026quot;LKM\u0026quot;; 声明了一个全局静态字符指针变量 name，默认值为\u0026quot;LKM\u0026quot;\n在内核模块中应该尽量避免使用全局变量，因为全局变量会被整个内核共享。所以应该使用 static 来限制变量在模块中的作用域，如果一定要使用全局变量的话，最好给这个变量加上前缀，以确保它在内核中是唯一的。\nmodule_param(name, type, permissions) 定义在 linux/moduleparam.h#L125\nname 名字：向用户显示的参数名称和模块中的变量名称\ntype 参数类型：byte, short, ushort, int, uint, long, ulong, charp, bool, invbool\npermissions 权限：值为 0 时，禁用该项，0444 所有人可读，0644 root用户可写，这里的写法和文件权限一致。\nMODULE_PARM_DESC 参数描述，会显示在 modinfo 中\n调用 1 2 3  root@AliECS:~/dev/kernel/hello# insmod hello.ko name=World root@AliECS:~/dev/kernel/hello# dmesg [103386.179203] Hello World!   参考  Writing a Linux Kernel Module — Part 1: Introduction linux 下的浮点运算 Linux Device Drivers : 3rd Edition ","description":"","id":1,"section":"posts","tags":["Linux","Kernel","Module"],"title":"Linux Kernel 实践(一)：Hello LKM","uri":"https://limxw.com/posts/linux-kernel-%E5%AE%9E%E8%B7%B5%E4%B8%80hello-lkm/"},{"content":"最近在使用 WSL 作为开发环境，但有些图形化软件无法打开，例如 Qemu，通过 X11 Forwarding 来使得 Qemu 正常显示。\n什么是 X 协议 X 协议由 X server 和 X client 组成：\nX server 管理主机上与显示相关的硬件设置（比如显卡、硬盘、鼠标等），它负责屏幕画面的绘制与显示，以及将输入设置（如键盘、鼠标）的动作告知 X client。\nX client (即 X 应用程序) 则主要负责事件的处理（即程序的逻辑）。\n什么是 X11 Forwarding 一般情况下 X server 和 X client 在同一台主机上。但是， X server 和 X client 完全可以运行在不同的机器上，只要彼此通过 X 协议通信即可。\n于是，我们可以通过 SSH X11 Forwarding 来将服务器上的GUI 程序 (X client)转发到本地显示 (X server)中 。X11 中的 X 指的是 X 协议，11 指的是采用 X 协议的第 11 个版本。\n在 Windows 上安装 X server   是选择使用 MobaXterm ，这个软件集成了 X server\n  安装 VcXsrv Windows X Server\n  安装完 VcXsrv 后，打开 XLaunch ：\n选择 Multiple windows ，只会传输软件窗口本身，而其他三个则会传输整个桌面环境。其余选项选择默认即可。\n然后在 .bashrc 或 .zshrc 中添加显示器地址：\n1  export DISPLAY=localhost:0   同时确保在 /etc/ssh/sshd_config 中有 X11Forwarding yes 且未被注释掉。\n测试 1 2 3 4  # 安装 x11-apps $ sudo apt install x11-apps # 打开 xclock $ xclock   若出现如下窗口则开启成功：\n","description":"","id":2,"section":"posts","tags":["WSL","Qemu"],"title":"在 WSL 中使用 X11 Forwarding","uri":"https://limxw.com/posts/use-x11-in-wsl/"},{"content":"大二，在杭州，12月份没有雪，但依然很冷。\n总结 这一年都在折腾一些小项目，发现自己在编程方面的理论知识懂得太少，脑子里还是一直摆脱不掉想去计算机专业的想法。也不是不能自己去学，但机械自己的专业课内容就已经很多了，光是学这个就没有精力去干别的了。\n学了一年的机械专业课，发现自己果然还是不喜欢物理，但对工程图学还是蛮感兴趣的，因为我挺喜欢画画，只是在画画上没有点天赋点。这种工业设计的不需要太多设计，还是蛮简单的。\n项目 Fischertechnik 和同学一起参加了第十六届浙江省大学生机械创意设计大赛慧鱼组，最后拿了省二等奖，这应该算是这一年最有成就的事情了。\nPython 这一年用 Python 写了不少爬虫，但都像开头说的，都是些自娱自乐的小项目\n 学校招标采购信息 namesilo 域名续费价格信息及提醒 选课系统自动抢课（未完工）  然后还在学校财务处那边接了个项目：学分清算系统，用来计算马上要毕业的大四学生的学费缴纳情况。\nArduino 然后也研究了硬件，用Arduino写了个“智能”门锁，本来想换成电磁锁，但要和学校报备，就改用步进电机来物理操控了。 ESP8266 做终端，MFRC522 读取一卡通信息，步进电机拉动/释放门闩。\nNode.js 为了实现远程控制“智能”门锁，用 Node.js 写了个服务端，用 WebSocket 来和 ESP8266 长连接，访问网页验证身份信息后可以直接开关宿舍门。\n消费  Samsung Tab S4  在 iPad 和三星平板上纠结了很久，最后还是入了三星，没钱是其一，其二是安卓比iPad OS 要开放太多了，换了 iPhone 7 之后就很久没玩过 Android 了，最后购入到使用，还是十分满意的。\nHonor Magic 2  24期分期免息真香。但买的主要原因是因为我有三张卡，一张是家里的，一张绑了支付宝和很多银行卡的，还有一张学校的。虽然因为滑盖设计导致手机很重，但这种没有刘海，不是挖孔的屏幕在视觉体验上确实很惊艳，\nOclean X  牙口不好，有段时间牙龈发炎严重，导致很疼，除了戒辛辣以外还得勤刷牙。但是因为小时候习惯不好，刷牙总是草草了事，于是就买了电动牙刷，提高清洁效果。不过说实话，牙刷上有个显示屏确实没啥用。\n京东京造 马丁靴  这应该是这一年在服装上买到的最满意的东西了，不仅增高，而且百搭好看（外观上和红翼非常像）。\n影视 电视剧 这一年看了非常多的电视剧，大概我碌碌无为的原因就在这了吧，列一下我觉得好看的。\n 《我们与恶的距离》 《秘密森林》 《我的大叔》 《去他*的世界》 《轮到你了》（可恶，烂尾了！ 《非自然死亡》 《亿万》 《超感猎杀》  电影 电影的话补了挺多以前想看的老电影，退了学生会之后就基本没人一起去看院线片了，不过自己一个人去电影院看电影也别有一般风味，可以沉浸在电影世界里面。\n 《寄生虫》 《82年生的金智英》 《小丑》 《天气之子》 《哪吒之魔童降世》（希望之后的国产动画电影能出更多的精品吧 《复仇者联盟4：终局之战》  展望 2020 正视自己的不足，改进，创造更多价值。\n","description":"","id":3,"section":"posts","tags":null,"title":"2019年终总结","uri":"https://limxw.com/posts/2019-summary/"},{"content":"想给 Hexo 添加一个后台管理页面，可以在浏览器上开箱即用。然后发现了JAMstack（JavaScript+APIs+Markup），通过 JavaScript 和 API 在前端直接增删改查，再触发 CI 来构建、部署。Netlify CMS 就是这样一个 Serverless 的 CMS。\n配置插件 首先安装 hexo-netlify-cms\n1  npm i hexo-netlify-cms --save\r  启用插件并设置自定义配置文件：\n1 2  netlify_cms:config_file:netlify-cms.yaml  在根目录下新建 netlify-cms.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  backend:name:github# 认证方式\rrepo:owner/repobranch:mastermedia_folder:source/images# 媒体源文件夹\rpublic_folder:/images# 生成后的媒体文件夹\rpublish_mode:editorial_workflow# 发布模式\r# 配置自动生成 collection\rauto_generator:post:all_posts:#enabled: true\rlabel:\u0026#34;Post\u0026#34;preview_path:\u0026#34;/posts/{{fields.urlname}}\u0026#34;# 预览地址\rfolder:\u0026#34;source/_posts\u0026#34;# 文章源文件夹\rcreate:true# 允许用户新建文章\reditor:preview:truepage:enabled:trueconfig:label:\u0026#34;Page\u0026#34;delete:falseeditor:preview:true# 设置全局表单\rglobal_fields:over_format:truedefault:- {label:\u0026#34;Title\u0026#34;, name:\u0026#34;title\u0026#34;, widget:\u0026#34;string\u0026#34;}- {label:\u0026#34;Publish Date\u0026#34;, name:\u0026#34;date\u0026#34;, widget:\u0026#34;datetime\u0026#34;, dateFormat:\u0026#34;YYYY-MM-DD\u0026#34;, timeFormat:\u0026#34;HH:mm:ss\u0026#34;, format:\u0026#34;YYYY-MM-DD HH:mm:ss\u0026#34;, required:false}- {label:\u0026#34;Update Date\u0026#34;, name:\u0026#34;updated\u0026#34;, widget:\u0026#34;datetime\u0026#34;, dateFormat:\u0026#34;YYYY-MM-DD\u0026#34;, timeFormat:\u0026#34;HH:mm:ss\u0026#34;, format:\u0026#34;YYYY-MM-DD HH:mm:ss\u0026#34;, required:false}- {label:\u0026#34;Tags\u0026#34;, name:\u0026#34;tags\u0026#34;, widget:\u0026#34;list\u0026#34;, required:false}- {label:\u0026#34;Categories\u0026#34;, name:\u0026#34;categories\u0026#34;, widget:\u0026#34;list\u0026#34;, required:false}- {label:\u0026#34;Permalink\u0026#34;, name:\u0026#34;urlname\u0026#34;, widget:\u0026#34;string\u0026#34;}- {label:\u0026#34;Body\u0026#34;, name:\u0026#34;body\u0026#34;, widget:\u0026#34;markdown\u0026#34;}#post:\r#page:\r  自建 GitHub Oauth 服务 因为我的博客是用 Travis-CI 自动部署到阿里云上，所以没办法用 Git-Gateway 来身份认证。\n而 GitHub Oauth 认证需要服务器验证，解决方法有两个：\n Netlify 提供 自己搭建  在使用 Netlify 的接口时出现无法认证的问题（应该是要在 Netlify 里面绑定域名），耦合度太高了不是很喜欢，而且速度有时候很慢，所以自己搭了一个。\n项目地址：netlify-cms-oauth-provider-python\n首先要修改配置文件：\n1 2 3 4 5  backend:name:githubrepo:owner/repobranch:masterbase_url:https://app.limxw.com# GitHub Oauth 服务地址\r  使用 Docker 部署：\n 使用配置文件：.env  1 2 3  OAUTH_CLIENT_ID=12345OAUTH_CLIENT_SECRET=balabalaREDIRECT_URL=https://your.server.com/callback  REDIRECT_URL：如果需要回调地址与 Oauth 应用程序配置中提供的不同，设置此项。\n1 2 3 4  docker run -itd \\\r -v /your/path/.env:/usr/src/app/.env \\\r -p 7676:80 \\\r winglim/netlifycms-oauth\r  使用环境变量  1 2 3 4  docker run -itd \\\r -e OAUTH_CLIENT_ID=12345 OAUTH_CLIENT_SECRET=balabala \\\r -p 7676:80 \\\r winglim/netlifycms-oauth\r  之后只需要用 nginx 或者 caddy 等软件将域名反向代理到 ip:7676 即可（也可以修改成其他端口\n","description":"","id":4,"section":"posts","tags":["Hexo","Netlify"],"title":"Hexo 使用 Netlify CMS","uri":"https://limxw.com/posts/hexo-netlify-cms/"},{"content":"为了给笔记本装 Mac OS + Windows 双系统，买了一块新固态：东芝RC500，顺便做一个不专业的简单评测。\n一开始以为小米笔记本PRO的第二个 M.2 2280 接口只能用 SATA3 协议的硬盘，查了一下发现是兼容 NVME 和 SATA3 的。不过主硬盘接口的 PCIe 3.0 x4 ，副硬盘接口是 PCIe 3.0 x2 。\n东芝RC500是 PCIe 3.0 x4 的固态，理论上来说插到 PCIe 3.0 x2 的接口上速度会损失一半左右，但实际测试中只有 4K 写入速度损失较大，其他读写损失不大。\n开箱 平平无奇的包装盒，虽然东芝的固态硬盘改名为 KIOXIA（铠侠）了，但 RC500 的包装盒用的还是沿用 TOSHIBA。\nRC500支持NVMe 1.3标准。缓存用的是 H5AN4G6NBJR-UHC，海力士DDR4 DRAM缓存颗粒。主控是东芝 TC58NC1202GST，支持四通道。\n颗粒是东芝原厂的 96 层 TLC。\n性能测试 Crystal Disk Info 传输模式是 PCIe 3.0 x2，待机温度为37度。\nCrystal Disk Mark 顺序读写超过了官方标注的 1700MB/S 和 1600MB/s 4KiB Q32T1 和 4KiB Q1T1 的读取有 PCIe 3.0 x4 下的 70% 左右，而写入就只有 50% 了。\nAS SSD Benchmark 同样的，在 PCIe 3.0 x4 下跑分大概在 4700 左右，PCIe 3.0 x2 下损失了10%左右。\n所以总体而言，插在小米笔记本PRO第二个硬盘接口上，除了4K写入损失较大以外，其他性能基本正常发挥，没有浪费。\n","description":"","id":5,"section":"posts","tags":["SSD"],"title":"东芝RC500开箱及简单评测","uri":"https://limxw.com/posts/toshiba-rc500-evaluation/"},{"content":"在 Windows 下写代码，配置环境总有点蛋疼，而 Linux 的桌面环境又经常会有些bug，于是就给自己笔记本装了个 Hackintosh，不过在笔记本上并不是很完美，记录一下一些解决办法。\nWIFI及蓝牙 使用的硬件  COMFAST 811AC 绿联蓝牙接收器（CSR8510）  因为 macOS 没有 Intel 的 WIFI 驱动，所以小米笔记本板载 WIFI 没办法使用，然后我两个 m.2 口都装了硬盘，没办法用拆机网卡，所以只能使用 USB 网卡。\n而且蓝牙驱动也有问题，不能热加载，就是说想连蓝牙得先在 Windows 上连接，然后重启进入 Hackintosh 才能连接。\n该软件包与此版本的 macOS 不兼容 在安装 WIFI 驱动的时候会出现这个问题：这是因为在 macOS Catalina 中，对系统读写权限加了限制，需要允许安装任意来源的 App，并挂载根目录，才能安装。\n1 2 3  sudo spctl --master-disable # 允许任意来源\rsudo mount -uw / # 挂载根目录\rkillall Finder # 杀掉Finder\r  禁用自带蓝牙 想使用 USB 蓝牙接收器，需要先把笔记本自带的禁用。\n我使用的是 XiaoMi-Pro-Hackintosh 这个 EFI，只需要将 SSDT-USBBT.aml 替换掉/EFI/CLOVER/ACPI/patched/SSDT-USB.aml 即可禁用。\n需要安装驱动的 USB 蓝牙接收器参考这里：蓝牙解决方案\n","description":"","id":6,"section":"posts","tags":["hackintosh","xiaomi"],"title":"小米笔记本PRO折腾黑苹果记","uri":"https://limxw.com/posts/mi-book-pro-with-hackintosh/"},{"content":"最近重新折腾了一下博客，从动态的 Typecho，WordPress，Ghost 到静态的 Hexo，Hugo 都试了一遍，最后还是决定用 Hexo，仅以此文纪念曾经的博客们。\nPart1 WordPress 最早开始接触到网站应该是2014年，还在读初中的时候，最近看到了 discuz 又还魂了1，想起了当时入坑是因为想要用 dizcuz 搭一个自己的论坛，花了很多时间去找教程，研究了 PHP 和 MySQL 把属于自己的 discuz 论坛搭了起来。\n但是搭完之后发现，论坛只有自己一个人，也没有什么实质性内容能够吸引别人加进来，最后论坛的想法也就不了了之了。\n从 discuz 开始，就逐渐入了网站的坑，既然论坛不行的话就开始捣鼓博客，从 freehao123 上了解了很多关于虚拟主机的知识，尝试了很多免费的虚拟主机和注册了 .tk，.cf 这类免费域名。\n因为 WordPress 用户群体多，也容易找到很多问题的解决方式，所以第一个博客就用了 WordPress 搭了起来。\n但是因为是在免费虚拟主机上搭建的，在当时WordPress 还是是十分重的，而且免费的虚拟主机大多都是在国外，光连接到网站就很费劲了，免费的虚拟主机性能还鶸，导致整个博客访问起来很慢。\n在尝试了用各种缓存插件去优化之后，还是没能达到心理预期，就渐渐对 WordPress 失去了折腾的兴趣。\nPart2 GitHub Issues 因为没钱访问速度太慢放弃了 WordPress 之后，开始寻找其他可以托管的方案，在 v2ex 上逛的时候发现了 Mirror 这个项目：利用 GitHub Repo 的 Issues 来写博客。\n虽然当时 GitHub 的访问速度也不是很理想，但比免费的虚拟主机速度和稳定性都要好很多，评论也有邮件提醒，不用自己去配置，同时还原生支持 MarkDown 写作，用起来还是十分的舒心。\nPart3 FarBox \u0026amp; Bitcron 用 GitHub Issues 来写博客，可自由定制的东西太少了，然后想起之前用过 FarBox ，再去他们官网看的时候发现他们发布了一个新产品 Bitcron ，因为有用过 FarBox 和修改过他们默认主题的经验，就很快的博客转移到了 Bitcron 上，并且移植了一个新的主题：Bitcron-Theme-Silicon\n在放弃 WordPress 的时候发现了 Typecho，轻量，高效，源码+数据库表不到400kb，深得我心，也尝试去搭建过，但是因为那个时候已经高三了，没有时间去维护，毕竟还是穷，一个月要续费一次VPS，没有这个时间，所以博客一直放在 Bitcron 上。\nPart4 Typecho 毕业之后有了钱时间，买了好几个VPS和域名，就把博客迁移到了 Typecho 上，这次也移植了一个主题：Typecho-Theme-AirCloud ，但是有一天上去访问的时候，不知道为什么字体变的很丑，我也懒得去调试修改了，这也让我萌生了重新折腾博客的心思。\nPart5 Hexo 在之前的那么多个博客中，其实驱动我折腾的最主要一个原因就是主题，看到了别人做的好看的主题，然后就想着移植到另一个平台上，再用这个平台来写博客。\n相对于动态博客，静态博客的主题写起来要简单很多，想自己动手写一个主题，就尝试了比较热门的静态生成器 Hexo 和 Hugo。\n虽然说 Hugo 生成页面的速度和效率都要更好一些，但是在 Hexo 中，因为用的是nodejs，highlight.js 这一类插件可以直接生成渲染完之后的 HTML，而不用把 js 放到 footer 中，当用户访问时再动态渲染，提高了访问速度。\n不过这样一来，渲染时花费的时间就增多了，在 Hexo 中 highlight.js 挺影响渲染速度的2，但是现在文章不多的情况下用 Hexo 还是非常快的，先好好写文章，之后有需求了再考虑折腾。\n最后用了 Travis-CI 来自动部署，构建时多花的那些时间也不用太在意了。而且，用静态博客有一个好处：可以只想着怎么写文章，不用考虑怎么去优化页面速度。\nAll in all, let\u0026rsquo;s focus on writing.\n*[PHP]: PHP: Hypertext Preprocessor\n https://www.discuz.net/thread-3847247-1-1.html \u0026#x21a9;\u0026#xfe0e;\n https://blog.skk.moe/post/hexo-performance/#测试结果 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":7,"section":"posts","tags":["blog"],"title":"博客流浪记","uri":"https://limxw.com/posts/my-blog-touring/"},{"content":"这两天将博客迁移到 Hexo ，部署在阿里云上，备份放在 GitHub 上，然后自己动手给 Hexo 写了一个主题，名为 Typing，希望更加专注在写文章上。\n功能介绍：\n  自定义 favicon\n  自定义 keywords，优化SEO\n  自定义 footer 信息\n  使用 DisqusJS 实现评论\n  自定义 HTML 的 lang，不用 Hexo 的配置文件来定义是因为换成 zh-cn 后，Moment.js 生成的时间格式是 Chinese Style，比如 “十一月” 这种，然后我自己更喜欢英文的月份，所以在主题配置文件中加了这个选项\n  使用方式：\n1  git clone https://github.com/WingLim/Hexo-Theme-Typing.git themes/Typing\r  修改网站根目录下的_config.yml\n1  theme:Typing  GitHub Repo：Hexo-Theme-Typing\nTODO：\n  Optimizate SEO\n  Comment\n ","description":"","id":8,"section":"posts","tags":["Hexo","Theme"],"title":"Hexo 主题 Typing","uri":"https://limxw.com/posts/hexo-theme-typing/"},{"content":"A HDUer\n鶸鸡一个，主要玩 Web 和 Python，偶尔也会折腾一些热门/新奇的软硬件。\n喜欢用的网名是：WingLim、NULL、二木文\n以前也用过的名字：zhaiblog、lweiny\nDevices  小米笔记本PRO Honor Magic 2 Apple iPhone 7 Samsung Tab S4 黑加手环 Amazon Kindle 499 已经成尸体的小米6  ","description":"","id":9,"section":"","tags":null,"title":"About Me","uri":"https://limxw.com/about/"},{"content":"最近在用 Oh My ZSH! ，然后在 WSL(Windows Subsystem for Linux)上也安装了 zsh 和 Oh My ZSH! 但是在设置默认 SHELL 时出现了问题。\nLinux 下设置默认 SHELL 方法如下：\n1  chsh -s /bin/zsh\r  但重新在 CMD/POWERSHELL 上进入 WSL ，默认的 SHELL 还是 bash ，需要手动执行 $ zsh才能进入。\n于是在 Google 上查了一下，发现在 Microsoft 的 Github 上面有一个提交 Bug 的 Repository：Microsoft/WSL 上有一个 issue：\ncan\u0026rsquo;t change default shell #477\n出现这个问题的原因是在启动 WSL 时没有执行 login 相关的组件，而这些组件和设置默认 SHELL 有关。\n We don\u0026rsquo;t run login which is the component that normally sets those things up.\n 解决方法 打开 ~./bashrc 添加下列代码进去并保存即可。\n1  [[ $- == *i* ]] \u0026amp;\u0026amp; $(command -v zsh) || echo \u0026#34;ZSH is not installed\u0026#34;\r  命令的具体解释在这里：https://github.com/Microsoft/WSL/issues/477#issuecomment-441164103\n","description":"","id":10,"section":"posts","tags":["WSL","Linux"],"title":"WSL 中设置 zsh 为默认 SHELL","uri":"https://limxw.com/posts/wsl-use-zsh/"},{"content":"在社团的活动室发现了一台闲置的服务器，服务器用的是学校的网络，没有公网IP，只能局域网访问，所以用 frp 搭了个内网穿透，然后为了方便部署服务端，就写了个一键安装脚本。\n介绍 脚本会自动从 frp 中获取最新的 release\n注意：目前只有安装服务端的功能，并且只保留 frps 的二进制文件\n脚本创建一个 frps.service 来控制 frps 的开关，默认开启开机自启\nfrps 安装在 /usr/local/frp\n配置文件在 /usr/local/frp/frps.ini\n使用方法 安装 1 2 3  wget https://raw.githubusercontent.com/WingLim/frp_install_script/master/frps.sh\rsudo chmod +x frps.sh\rsudo ./frps.sh 2\u0026gt;\u0026amp;1 | tee frps.log\r  使用命令 1 2 3  systemctl start frps # 启动 frps\rsystemctl stop frps # 停止 frps\rsystemctl status frps # 关闭 frps\r  TODO：\n frp 一键安装客户端脚本 ","description":"","id":11,"section":"posts","tags":["frp","script"],"title":"frp 一键安装脚本","uri":"https://limxw.com/posts/frp-install-script/"}]