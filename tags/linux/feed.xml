<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 界限</title><link>https://blog.limx.dev/tags/linux/</link><description>Recent content in Linux on 界限</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 06 Mar 2020 23:17:11 +0800</lastBuildDate><atom:link href="https://blog.limx.dev/tags/linux/feed.xml" rel="self" type="application/rss+xml"/><item><title>Linux Kernel 实践(二)：劫持系统调用</title><link>https://blog.limx.dev/post/linux-kernel-practice-hijack-syscall/</link><pubDate>Fri, 06 Mar 2020 23:17:11 +0800</pubDate><guid>https://blog.limx.dev/post/linux-kernel-practice-hijack-syscall/</guid><description>使用系统为 Ubuntu，内核版本为 4.4.0-93-generic
劫持系统调用有风险，请不要在实体机上尝试。
前言 添加系统调用有两种方法
修改内核源代码，并重新编译内核 这种耗时耗力，比较麻烦，但是是在原有的系统调用中插入新的系统调用，不会出现冲突等问题。
通过内核模块重新映射系统调用地址 通过拦截系统调用表，将某个系统调用的地址修改成我们自定义的系统系统调用。
什么是系统调用表 在 Linux 中每个系统调用都有相应的系统调用号作为唯一的标识，内核维护一张系统调用表：sys_call_table。
在 64 位系统中，sys_call_table 的定义在 entry/syscall_64.c#L25
asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = { [0 ... __NR_syscall_max] = &amp;amp;sys_ni_syscall, #include &amp;lt;asm/syscalls_64.h&amp;gt;}; 其中 #include &amp;lt;asm/syscalls_64.h&amp;gt; 是通过 entry/syscalls/Makefile 以 entry/syscalls/syscall_64.tbl 为源文件编译生成的。
out := $(obj)/../../include/generated/asm syscall64 := $(srctree)/$(src)/syscall_64.tbl systbl := $(srctree)/$(src)/syscalltbl.sh $(out)/syscalls_64.h: $(syscall64) $(systbl) $(call if_changed,systbl) Makefile 通过 entry/syscalls/syscalltbl.sh 将 syscall_64.tbl 格式化成 __SYSCALL_${abi}($nr, $entry, $compat)
#!/bin/sh in=&amp;#34;$1&amp;#34; out=&amp;#34;$2&amp;#34; grep &amp;#39;^[0-9]&amp;#39; &amp;#34;$in&amp;#34; | sort -n | ( while read nr abi name entry compat; do abi=`echo &amp;#34;$abi&amp;#34; | tr &amp;#39;[a-z]&amp;#39; &amp;#39;[A-Z]&amp;#39;` if [ -n &amp;#34;$compat&amp;#34; ]; then echo &amp;#34;__SYSCALL_${abi}($nr, $entry, $compat)&amp;#34; elif [ -n &amp;#34;$entry&amp;#34; ]; then echo &amp;#34;__SYSCALL_${abi}($nr, $entry, $entry)&amp;#34; fi done ) &amp;gt; &amp;#34;$out&amp;#34; 生成后的 syscall_64.</description></item><item><title>Linux Kernel 实践(一)：Hello LKM</title><link>https://blog.limx.dev/post/linux-kernel-practice-hello/</link><pubDate>Fri, 06 Mar 2020 18:18:09 +0800</pubDate><guid>https://blog.limx.dev/post/linux-kernel-practice-hello/</guid><description>使用系统为 Ubuntu，内核版本为 4.4.0-93-generic
什么是内核模块 Loadable Kernel Modules（LKM）即可加载内核模块，LKM可以动态地加载到内存中，无须重新编译内核。所以它经常被用于一些设备的驱动程序，例如声卡，网卡等等。
内核模块和一般的 C 语言程序不同，它不使用 main() 函数作为入口，并且有如下区别：
非顺序执行：内核模块使用初始化函数来进行注册，并处理请求，初始化函数运行后就结束了。 它可以处理的请求类型在模块代码中定义。 没有自动清理：内核模块申请的所有内存，必须要在模块卸载时手动释放，否则这些内存会无法使用，直到重启，也就是说我们需要在模块的卸载函数（也就是下文写到的退出函数）中，将使用的内存逐一释放。 会被中断：内核模块可能会同时被多个程序/进程使用，构建内核模块时要确保发生中断时行为一致和正确。想了解更多请看：Linux 内核的中断机制 更高级的执行特权：通常分配给内核模块的CPU周期比分配给用户空间程序的要多。编写内核模块时要小心，以免模块对系统的整体性能产生负面影响。 不支持浮点：在Linux内核里无法直接进行浮点计算，因为这样做可以省去在用户态与内核态之间进行切换时保存/恢复浮点寄存器 FPU的操作。 构建前的准备 通过包管理安装 Linux 内核头文件
sudo apt update apt-cache search linux-headers-$(uname -r) apt install linux-headers-$(uname -r) 开始写代码 引入头文件 #include &amp;lt;linux/init.h&amp;gt; // 用于标记函数的宏#include &amp;lt;linux/module.h&amp;gt; //加载内核模块到内核使用的核心头文件#include &amp;lt;linux/kernel.h&amp;gt; // 包含内核使用的类型、宏和函数定义模块信息 MODULE_LICENSE(&amp;#34;GPL&amp;#34;); // 许可类型，它会影响到运行时行为 MODULE_AUTHOR(&amp;#34;WingLim&amp;#34;); // 作者，当使用 modinfo 命令时可见 MODULE_DESCRIPTION(&amp;#34;A simple Linux driver to say hello.&amp;#34;); // 模块描述，参见 modinfo 命令 MODULE_VERSION(&amp;#34;0.1&amp;#34;); // 模块版本 如果没有定义 MODULE_LICENSE ，在编译和加载模块时会报 WARNING: modpost: missing MODULE_LICENSE()</description></item></channel></rss>